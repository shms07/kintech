"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.upload = void 0;
const chokidar_1 = __importDefault(require("chokidar"));
const fs_1 = __importDefault(require("fs"));
const KintoneApiClient_1 = __importStar(require("../KintoneApiClient"));
const messages_1 = require("../messages");
const util_1 = require("../util");
const MAX_RETRY_COUNT = 3;
const upload = (kintoneApiClient, manifest, status, options) => __awaiter(void 0, void 0, void 0, function* () {
    const boundMessage = (0, messages_1.getBoundMessage)(options.lang);
    const appId = manifest.app;
    let { retryCount, updateBody, updated } = status;
    try {
        if (!updateBody) {
            console.log(boundMessage("M_StartUploading"));
            try {
                const uploadFilesResult = yield getUploadFilesResult(boundMessage, kintoneApiClient, manifest);
                updateBody = createUpdatedManifest(manifest, uploadFilesResult);
                console.log(boundMessage("M_FileUploaded"));
            }
            catch (error) {
                console.log(boundMessage("E_FileUploaded"));
                throw error;
            }
        }
        if (!updated) {
            try {
                yield kintoneApiClient.updateCustomizeSetting(updateBody);
                console.log(boundMessage("M_Updated"));
                updated = true;
            }
            catch (error) {
                console.log(boundMessage("E_Updated"));
                throw error;
            }
        }
        try {
            yield kintoneApiClient.deploySetting(appId);
            yield kintoneApiClient.waitFinishingDeploy(appId, () => console.log(boundMessage("M_Deploying")));
            console.log(boundMessage("M_Deployed"));
        }
        catch (error) {
            console.log(boundMessage("E_Deployed"));
            throw error;
        }
    }
    catch (error) {
        const params = {
            error,
            manifest,
            updateBody,
            updated,
            retryCount,
            options,
            boundMessage,
            kintoneApiClient,
        };
        yield handleUploadError(params);
    }
});
exports.upload = upload;
const getJsCssFiles = (manifest) => {
    return [
        manifest.desktop.js,
        manifest.desktop.css,
        manifest.mobile.js,
        manifest.mobile.css,
    ];
};
const getUploadFilesResult = (boundMessage, kintoneApiClient, manifest) => __awaiter(void 0, void 0, void 0, function* () {
    const uploadFilesResult = [];
    for (const files of getJsCssFiles(manifest)) {
        const results = [];
        for (const file of files) {
            const result = yield kintoneApiClient.prepareCustomizeFile(file);
            if (result.type === "FILE") {
                console.log(`${file} ` + boundMessage("M_Uploaded"));
            }
            results.push(result);
        }
        uploadFilesResult.push(results);
    }
    return uploadFilesResult;
});
const createUpdatedManifest = (manifest, uploadFilesResult) => {
    return Object.assign({}, manifest, {
        desktop: {
            js: uploadFilesResult[0],
            css: uploadFilesResult[1],
        },
        mobile: {
            js: uploadFilesResult[2],
            css: uploadFilesResult[3],
        },
    });
};
const handleUploadError = (params) => __awaiter(void 0, void 0, void 0, function* () {
    let { error, manifest, updateBody, updated, retryCount, options, boundMessage, kintoneApiClient, } = params;
    const isAuthenticationError = error instanceof KintoneApiClient_1.AuthenticationError;
    retryCount++;
    if (isAuthenticationError) {
        throw new Error(boundMessage("E_Authentication"));
    }
    else if (retryCount < MAX_RETRY_COUNT) {
        yield (0, util_1.wait)(1000);
        console.log(boundMessage("E_Retry"));
        yield (0, exports.upload)(kintoneApiClient, manifest, { retryCount, updateBody, updated }, options);
    }
    else {
        throw error;
    }
});
const run = (params) => __awaiter(void 0, void 0, void 0, function* () {
    const { username, password, oAuthToken, basicAuthUsername, basicAuthPassword, baseUrl, manifestFile, options, } = params;
    const boundMessage = (0, messages_1.getBoundMessage)(options.lang);
    const manifest = JSON.parse(fs_1.default.readFileSync(manifestFile, "utf8"));
    const status = {
        retryCount: 0,
        updateBody: null,
        updated: false,
    };
    // support an old format for customize-manifest.json that doesn't have mobile.css
    manifest.mobile.css = manifest.mobile.css || [];
    const files = manifest.desktop.js
        .concat(manifest.desktop.css, manifest.mobile.js, manifest.mobile.css)
        .filter((fileOrPath) => !(0, util_1.isUrlString)(fileOrPath));
    const kintoneApiClient = new KintoneApiClient_1.default(username, password, oAuthToken, basicAuthUsername, basicAuthPassword, baseUrl, options);
    yield (0, exports.upload)(kintoneApiClient, manifest, status, options);
    if (options.watch) {
        const watcher = chokidar_1.default.watch(files, {
            // Avoid that multiple change events were fired depending on which OS or text editors you are using with
            // Note that there would be higher possibility to get errors if you set smaller value of 'stabilityThreshold'
            awaitWriteFinish: {
                stabilityThreshold: 2000,
                pollInterval: 100,
            },
        });
        console.log(boundMessage("M_Watching"));
        watcher.on("change", () => (0, exports.upload)(kintoneApiClient, manifest, status, options));
    }
});
exports.run = run;
__exportStar(require("./import"), exports);
__exportStar(require("./init"), exports);
//# sourceMappingURL=index.js.map